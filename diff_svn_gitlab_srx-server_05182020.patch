--- ./src/tools/rpkirtr_svr.c	2017-12-05 16:45:33.000000000 -0500
+++ /opt/project/NIST-gitlab/srx-server/./src/tools/rpkirtr_svr.c	2020-05-18 02:16:10.099963091 -0400
@@ -32,8 +32,31 @@
  *
  * Changelog:
  * -----------------------------------------------------------------------------
- * 0.5.1.0  - 2017/10/12 - oborchert
+ * 0.5.1.0  - 2018/06/09 - oborchert
+ *            * Added command 'echo' to allow printing messaged from a script
+ *              to the console. CMD_ID_ECHO
+ *            * Added command waitFor <client-ip> to allow to wait until the 
+ *              specific client connects. This will time out after 60 seconds.
+ *            * Added command pause to allow to wait until any key is pressed.
+ *          - 2018/03/09 - oborchert 
+ *            * BZ1263: Merged branch 0.5.0.x (version 0.5.0.4) into trunk 
+ *              of 0.5.1.0.
+ *          - 2017/10/12 - oborchert
  *            * BZ1103: Fixed incorrect RFC reference
+ * 0.5.0.5  - 2018/05/17 - oborchert
+ *            * (merged branch 0.5.0 into trunk)
+ *          - 2018/04/24 - oborchert
+ *            * Modified the function printLogMessage to use the current log 
+ *              level rather than hard coded log level.
+ *            * Change default value for verbose to false.
+ * 0.5.0.4  - 2018/03/08 - oborchert
+ *            * Fixed incorrect processing of parameters.
+ *            * Fixed incorrect syntax printout.
+ * 0.5.0.3  - 2018/03/01 - oborchert
+ *            * Added proper program stop when help parameter is provided.
+ *            * Fixed printout for router keys.
+ *          - 2018/02/28 - oborchert
+ *            * Fixed usage of incorrect version number.
  * 0.5.0.1  - 2017/09/25 - oborchert
  *            * Fixed compiler warnings.
  * 0.5.0.0  - 2017/07/08 - oborchert
@@ -211,6 +234,9 @@ typedef struct {
 #define CMD_ID_RUN          17
 #define CMD_ID_SLEEP        18
 #define CMD_ID_KEY_LOC      19
+#define CMD_ID_ECHO         20
+#define CMD_ID_WAIT_CLIENT  21
+#define CMD_ID_PAUSE        22
 
 #define DEF_RPKI_PORT    323
 #define UNDEF_VERSION    -1
@@ -220,7 +246,7 @@ typedef struct {
 #ifdef PACKAGE_VERSION
 const char* RPKI_RTR_SRV_VER          = PACKAGE_VERSION "\0";
 #else
-const char* RPKI_RTR_SRV_VER          = "> 0.4\0";
+const char* RPKI_RTR_SRV_VER          = "> 0.5.0\0";
 #endif
 const char* RPKI_RTR_SRV_NAME         = "RPKI Cache Test Harness\0";
 const char* HISTORY_FILENAME          = ".rpkirtr_svr.history\0";
@@ -255,10 +281,16 @@ ServerSocket svrSocket;
 /** A list of cache clients */
 CacheClient* clients   = NULL;
 /** Verbose mode on or off */
-bool         verbose   = true;
+bool         verbose   = false;
 /** the current cache session id value */
 uint16_t     sessionID = 0;
 
+/** Used to indicate if the system is in a controlled wait loop. This allows
+ *  The CTRL+C handler to not initiate a shutdown but set the ctr__c variable
+ *  to true. */
+bool         inWait    = false;
+/** Indicates if the ctrl+c combination was pressed.  */
+bool         ctrl_c    = false;
 /** Location (directory) where the key files are stored. */
 char keyLocation[LINE_BUF_SIZE];
 
@@ -354,7 +386,8 @@ bool dropSession(int* fdPtr)
  *
  * @return
  */
-bool sendPDUWithSerial(int* fdPtr, RPKIRouterPDUType type, uint32_t serial, uint8_t version)
+bool sendPDUWithSerial(int* fdPtr, RPKIRouterPDUType type, uint32_t serial, 
+                       uint8_t version)
 {
   uint8_t                pdu[sizeof(RPKISerialQueryHeader)];
   RPKISerialQueryHeader* hdr;
@@ -375,17 +408,18 @@ bool sendPDUWithSerial(int* fdPtr, RPKIR
  * Send a CACHE RESET to the client.
  *
  * @param fdPtr the socket connection
+ * @param version The version for this session.
  *
  * @return true id the packet was send successful.
  */
-bool sendCacheReset(int* fdPtr)
+bool sendCacheReset(int* fdPtr, u_int8_t version)
 {
   uint8_t               pdu[sizeof(RPKICacheResetHeader)];
   RPKICacheResetHeader* hdr;
 
   // Create PDU
   hdr = (RPKICacheResetHeader*)pdu;
-  hdr->version  = RPKI_RTR_PROTOCOL_VERSION;
+  hdr->version  = version;
   hdr->type     = (uint8_t)PDU_TYPE_CACHE_RESET;
   hdr->reserved = 0;
   hdr->length   = htonl(sizeof(RPKICacheResetHeader));
@@ -397,10 +431,11 @@ bool sendCacheReset(int* fdPtr)
  * Send a CACHE RESPONSE to the client.
  *
  * @param fdPtr the socket connection
+ * @param version The version number of this session
  *
  * @return true id the packet was send successful.
  */
-bool sendCacheResponse(int* fdPtr, int version)
+bool sendCacheResponse(int* fdPtr, u_int8_t version)
 {
   uint8_t                  pdu[sizeof(RPKICacheResetHeader)];
   RPKICacheResponseHeader* hdr;
@@ -426,7 +461,7 @@ bool sendCacheResponse(int* fdPtr, int v
  *                ignored.
  */
 void sendPrefixes(int* fdPtr, uint32_t clientSerial, uint16_t clientSessionID,
-                  bool isReset, int version)
+                  bool isReset, u_int8_t version)
 {
   // No need to send the notify anymore
   service.notify = false;
@@ -445,7 +480,7 @@ void sendPrefixes(int* fdPtr, uint32_t c
            && (checkSerial(cache.minPSExpired, cache.maxSExpired, clientSerial))
           )
   { // Serial is incorrect, send a Cache Reset
-    if (!sendCacheReset(fdPtr))
+    if (!sendCacheReset(fdPtr, version))
     {
       ERRORF("Error: Failed to send a 'Cache Reset'\n");
     }
@@ -459,7 +494,7 @@ void sendPrefixes(int* fdPtr, uint32_t c
     }
     else
     {
-      printf("Cache size = %u\n", cache.entries.size);
+      OUTPUTF(true, "Cache size = %u\n", cache.entries.size);
       if (cache.entries.size > 0) // there is always a root.
       {
         ValCacheEntry* cEntry;
@@ -589,7 +624,8 @@ void sendPrefixes(int* fdPtr, uint32_t c
       OUTPUTF(true, "Sending an 'End of Data (max. serial = %u)\n",
               cache.maxSerial);
 
-      if (!sendPDUWithSerial(fdPtr, PDU_TYPE_END_OF_DATA, cache.maxSerial, cache.version))
+      // was sending cache version, not session version.
+      if (!sendPDUWithSerial(fdPtr, PDU_TYPE_END_OF_DATA, cache.maxSerial, version))
       {
         ERRORF("Error: Failed to send a 'End of Data'\n");
       }
@@ -616,7 +652,7 @@ int sendSerialNotifyToAllClients()
     for (client = clients; client; client = client->hh.next)
     {
       if (!sendPDUWithSerial(&client->fd, PDU_TYPE_SERIAL_NOTIFY,
-                             cache.maxSerial, cache.version))
+                             cache.maxSerial, client->version))
       {
         ERRORF("Error: Failed to send a 'Serial Notify\n");
       }
@@ -643,7 +679,7 @@ int sendCacheResetToAllClients()
 
     for (client = clients; client; client = client->hh.next)
     {
-      if (!sendCacheReset(&client->fd))
+      if (!sendCacheReset(&client->fd, client->version))
       {
         ERRORF("Error: Failed to send a 'Cache Reset\n");
       }
@@ -662,10 +698,14 @@ int sendCacheResetToAllClients()
  * @param the error number to be send
  * @param data contains the error number followed by the PDU and text. The
  * character - as PDU or text generates a PDU / text length of zero.
+ * @param version The version of this session.
+ * 
  * @return true if it could be send.
  */
-bool sendErrorPDU(int* fdPtr, RPKICommonHeader* pdu, char* reason)
+bool sendErrorPDU(int* fdPtr, RPKICommonHeader* pdu, char* reason, 
+                  u_int8_t version)
 {
+  // @TODO: Fix this code.
   printf("ERROR: invalid PDU because of %s\n", reason);
 //  uint8_t                  pdu[sizeof(RPKIErrorReportHeader)];
 //  RPKICacheResponseHeader* hdr;
@@ -943,23 +983,24 @@ void handleClient(ServerSocket* svrSock,
   // read the beginning of the header to see how many bytes are actually needed
   while (recvNum(&sock, &hdr, sizeof(RPKICommonHeader)))
   {
-    switch (ccl->version)
+    if (hdr.version > RPKI_RTR_PROTOCOL_VERSION)
     {
-      case UNDEF_VERSION:
-        ccl->version = hdr.version;
-        break;
-      case 0:
-      case 1:
+      sendErrorPDU(&ccl->fd, &hdr, "Unsupported Version", 
+                   RPKI_RTR_PROTOCOL_VERSION);
+      close(sock);
         break;
-      default:
-        sendErrorPDU(&ccl->fd, &hdr, "Unsupported Version");
-        continue;
     }
-    if (ccl->version != hdr.version)
+    if (ccl->version == UNDEF_VERSION)
     {
-      // Send error.
-      sendErrorPDU(&ccl->fd, &hdr, "Illegal switch of version number!");
-      continue;
+      ccl->version = hdr.version;
+    } 
+    else if (hdr.version != ccl->version)
+    {
+      // @TODO: Fix this and also close connection in this case.
+      sendErrorPDU(&ccl->fd, &hdr, "Illegal switch of version number!", 
+                   ccl->version);
+      close(sock);
+      break;
     }
 
     // determine the remaining data that needs to be received - if any
@@ -992,7 +1033,7 @@ void handleClient(ServerSocket* svrSock,
     // Time since the last request
     diffReq = lastReq - time(NULL);
 
-    printf ("Received Data From Client [%x]...\n", sock);
+    OUTPUTF(true, "Received Data From Client [%x]...\n", sock);
 
     // Action depending on the type
     switch ((RPKIRouterPDUType)hdr.type)
@@ -1414,6 +1455,15 @@ int showHelp(char* command)
            "                 Send a SERIAL NOTIFY to all clients.\n"
            "  - reset\n"
            "                 Send a CACHE RESET to all clients.\n"
+           "  - echo [text]\n"
+           "                 Print the given text on the console window.\n"
+           "  - waitFor <client-IP>\n"
+           "                 Wait until the client with the given IP connect.\n"
+           "                 This function times out after 60 seconds.\n"
+           "  - pause [prompt]\n"
+           "                 Wait until any key is pressed. This is mainly\n"
+           "                 for scripting scenarios. If no prompt is used,\n"
+           "                 the default prompt will be applied!\n"
 
            "\n"
            "Program Commands:\n"
@@ -1489,9 +1539,35 @@ int showHelp(char* command)
                    "              Use \"-\" to not include a message.\n"
       );
     }
+    else if (strcmp(command, "echo")==0)
+    {
+      SHOW_CMD_HLP("echo [text]",
+                   "This command allows to display a given text on the console "
+                   "window. It is mainly useful for scripted scenarios, where "
+                   "follow up actions by the user is needed or where the "
+                   "it makes sense to inform about the script process.\n"
+      );
+    }
+    else if (strcmp(command, "waitFor")==0)
+    {
+      SHOW_CMD_HLP("waitFor <client-IP>",
+                   "This command waits for a client to connect but will time "
+                   "out after 60 seconds and writes a timeout statement on the "
+                   "console.\n"
+      );
+    }
+    else if (strcmp(command, "pause")==0)
+    {
+      SHOW_CMD_HLP("pause [prompt]",
+                   "This command is for scripting scenarios the have user "
+                   "interactions to continue. For instance CTRL+C will "
+                   "further loading or deleting of cache entries. In case "
+                   "no prompt is provided the default prompt is used.\n"
+      );
+    }
     else
     {
-      printf ("Detailed help for '%s' available - use standard help!\n",
+      printf ("No detailed help for '%s' available - use standard help!\n",
               command);
     }
   }
@@ -1581,6 +1657,45 @@ unsigned char hex2bin_byte(char* in)
 }
 
 /**
+ * This function loops through the list of clients and checks if one client
+ * matches the given IP address.
+ * 
+ * @param clientIP The IP address the clients will be compared too.
+ * 
+ * @return true if one client exists with the given IP address.
+ * 
+ * @since 0.5.1.0 
+ */
+bool hasClient(char* clientIP)
+{
+  #define BUF_SIZE (MAX_IP_V6_STR_LEN + 6)
+  char*        buf = malloc(BUF_SIZE);
+  char*        ipStr1 = malloc(BUF_SIZE);
+  char*        ipStr2 = malloc(BUF_SIZE);
+  CacheClient* cl;
+  bool         retVal = false;
+
+  if ((clientIP != NULL) && (HASH_COUNT(clients) != 0))
+  {
+    cl = clients;
+    snprintf(ipStr1, BUF_SIZE, "%s:", clientIP);
+    while (cl != NULL)
+    {
+      socketToStr(cl->fd, true, buf, BUF_SIZE);
+      snprintf(ipStr2, strlen(ipStr1)+1, "%s:", buf);
+      // ==0 because the client also has the port number attached.
+      retVal = strcmp(ipStr1, ipStr2) == 0;
+      cl = retVal ? cl=NULL : cl->hh.next;
+    }
+  }
+
+  free (buf);
+  free (ipStr1);
+  free (ipStr2);
+  return retVal;
+}
+
+/**
  * Read the router key certificate file.
  *
  * @param arg the arguments (asn algoid certFile)
@@ -1863,6 +1978,7 @@ int printCache()
   unsigned    pos = 1;
   ValCacheEntry* cEntry;
   char        ipBuf[IPBUF_SIZE];
+  int         idx=0;
 
   now = time(NULL);
 
@@ -1883,12 +1999,16 @@ int printCache()
 
       if (cEntry->isKey)
       {
-        printf("SKI: %02X%02X%02X%02X, OAS=%u",
-                (unsigned char)cEntry->ski[0], (unsigned char)cEntry->ski[1],
-                (unsigned char)cEntry->ski[2], (unsigned char)cEntry->ski[3],
-                ntohl(cEntry->asNumber));
+        printf("SKI: ");
+        for (idx = 0; idx < SKI_LENGTH; idx++)
+        {
+          printf ("%02X", (u_int8_t)cEntry->ski[idx]);
+        }
+        printf (", OAS=%u", ntohl(cEntry->asNumber));
       }
-      else if (cEntry->isV6)
+      else
+      {
+        if (cEntry->isV6)
       {
         printf("%s/%hhu, OAS=%u",
                ipV6AddressToStr(&cEntry->address.v6, ipBuf, IPBUF_SIZE),
@@ -1902,6 +2022,7 @@ int printCache()
       }
       printf(", Max.Len=%hhu, Serial=%u, Prev.Serial=%u",
              cEntry->prefixMaxLength, cEntry->serial, cEntry->prevSerial);
+      }
 
       if (cEntry->expires > 0)
       {
@@ -2111,7 +2232,7 @@ int listClients()
   {
     for (cl = clients; cl; cl = cl->hh.next, idx++)
     {
-      printf("%u: %s\n", cl->fd, socketToStr(cl->fd, true, buf, BUF_SIZE));
+      printf("%i: %s\n", cl->fd, socketToStr(cl->fd, true, buf, BUF_SIZE));
     }
   }
 
@@ -2192,6 +2313,90 @@ int pauseExecution(char* noSeconds)
 }
 
 /**
+ * Display the given text on the screen. A new line will be added at the end.
+ * 
+ * @param text the text to be printed.
+ * 
+ * @return CMD_ID_ECHO
+ * 
+ * @since 0.5.1.0
+ */
+int printText(char* text)
+{
+  if (text == NULL)
+  {
+    text = "";
+  }
+  printf ("%s\n", text);
+  
+  return CMD_ID_ECHO;
+}
+
+/**
+ * Wait for a client to connect but no longer than 60 seconds
+ * 
+ * @param clientIP The IP of the client
+ * 
+ * @return CMD_ID_WAIT_CLIENT 
+ * 
+ * @since 0.5.1.0
+ */
+int waitForClient(char* clientIP)
+{
+  int  timeout = 60;
+  bool found = hasClient(clientIP);
+  
+  // initialize flags
+  inWait = true;
+  ctrl_c = false;
+  char* space = " ";
+  
+  if (clientIP != NULL)
+  {
+    printf("Waiting for client (%s)", clientIP);
+    while (!found && (timeout != 0) && !ctrl_c)
+    {
+      space = "";
+      found = hasClient(clientIP);
+      found = false;
+      if (!found && !ctrl_c)
+      {
+        printf(".");
+        sleep(1);
+        timeout--;
+      }
+    }
+    printf("%s%s!\n", space, found ? "connected" 
+                                   : ctrl_c ? "stopped" : "timeout");
+  }
+  else
+  {
+    printf("No IP provided!\n");
+  }
+  
+  // clear flags
+  ctrl_c = false;
+  inWait = false;
+    
+  return CMD_ID_WAIT_CLIENT;
+}
+
+/**
+ * This function waits until any key was pressed.
+ * 
+ * @param prompt Contains the prompt. If not provided the default prompt will 
+ *               be used.
+ * 
+ * @return CMD_ID_PAUSE 
+ */
+int doPause(char* text)
+{
+  printf("%s ", text != NULL ? text : "Press any key to continue!");
+  fgetc(stdin);   
+  return CMD_ID_PAUSE;
+}
+
+/**
  * Doesn't really do anything
  *
  * @return CMD_ID_QUIT
@@ -2231,6 +2436,9 @@ char* commands[] = {
   "sleep",
   "quit",
   "exit",
+  "echo",
+  "waitFor",
+  "pause",
   "*",
   NULL};
 
@@ -2313,6 +2521,10 @@ int handleLine(char* line)
   CMD_CASE("clients",   listClients);
   CMD_CASE("run",       executeScript);
   CMD_CASE("sleep",     pauseExecution);
+  CMD_CASE("waitFor",   waitForClient);
+  CMD_CASE("pause",     doPause);
+  
+  CMD_CASE("echo",      printText);
 
   CMD_CASE("quit",      processQuit);
   CMD_CASE("exit",      processQuit);
@@ -2451,9 +2663,16 @@ void serviceTimerExpired(int id, time_t
   }
 }
 
+/** 
+ * Use the log level specified or if verbose is enabled.
+ * 
+ * @param level The log level of the message/
+ * @param fmt The format string
+ * @param args The argument list matching the format string.
+ */
 void printLogMessage(LogLevel level, const char* fmt, va_list args)
 {
-  if ((level == LEVEL_ERROR) || verbose)
+  if ((level == getLogLevel()) || verbose)
   {
     putc('\r', stdout);
     vprintf(fmt, args);
@@ -2469,9 +2688,11 @@ void printLogMessage(LogLevel level, con
  */
 void handleSigInt(int signal)
 {
-  printf ("exit\n");
-  // Let 'readline' return 0, i.e. stop the user-input loop
-  fclose(stdin);
+  if (!inWait)
+  {
+    printf ("\nUse command 'exit'\n");
+  }
+  ctrl_c = true;
 }
 
 
@@ -2529,6 +2750,8 @@ static void syntax(const char* prgName)
   printf ("  specify a script!\n");
   printf ("  If No port is specified the default port %u is used.\n",
           DEF_RPKI_PORT);
+  printf ("\n");
+  showVersion();
 }
 
 /**
@@ -2553,7 +2776,9 @@ static bool parseParams(int argc, const
   char* arg   = NULL;
   int idx     = 0;
 
-  for (idx = 1; (idx < argc) && !doHelp; idx++)
+  #define HMSG " - try '-?' for more info"
+
+  for (idx = 1; (idx < argc) && !doHelp && retVal; idx++)
   {
     arg = (char*)argv[idx];
     if (arg[0] == '-')
@@ -2590,48 +2815,69 @@ static bool parseParams(int argc, const
           }
           else
           {
-            printf ("ERROR: Log level missing!");
-            doHelp = true;
+            printf ("ERROR: Log level missing%s!\n", HMSG);
             retVal = false;
             eVal   = 1;
           }
           break;
           break;
         case 'f':
+          if (cfg->script == NULL)
+          {
           idx++;
           if (idx < argc)
           {
-            cfg->script = (char*)argv[idx++];
+              cfg->script = (char*)argv[idx];
           }
           else
           {
-            printf ("ERROR: filename missing!");
-            doHelp = true;
+              printf ("ERROR: filename missing%s!\n", HMSG);
+              retVal = false;
+              eVal   = 1;
+            }
+          }
+          else
+          {
+            printf ("ERROR: Script already added%s!\n", HMSG);
             retVal = false;
             eVal   = 1;
           }
           break;
         default:
-          printf ("ERROR: Invalid parameter '%s'\n", arg);
-          doHelp = true;
+          printf ("ERROR: Invalid parameter '%s'%s!\n", arg, HMSG);
           retVal = false;
           eVal   = 1;
           break;
       }
     }
-    else if (strcmp(arg, "help") == 0)
+    else if ((strcmp(arg, "help") == 0) || (arg[0] == '?'))
     {
       doHelp = true;
     }
     else if (cfg->port == 0)
     {
-      cfg->port = strtol(argv[1], NULL, 10);
+      cfg->port = strtol(arg, NULL, 10);
+    }
+    else
+    {
+      if (cfg->script == NULL)
+      {
+        cfg->script = arg;
+        printf ("WARNING: Script added but use -f <script> to add scripts in "
+                "the future.\n");
+      }
+      else
+      {
+        printf ("ERROR: Script already added%s!\n", HMSG);
+        retVal = false;
+      }
     }
   }
 
   if (doHelp)
   {
     syntax(argv[0]);
+    retVal = false;
   }
 
   // Configure the default port if not specified otherwise.
@@ -2660,6 +2906,11 @@ int main(int argc, const char* argv[])
 {
   pthread_t rlthread;
   int       ret = 0;
+  
+  // Disable printout buffering.
+  setbuf(stdout, NULL);
+  setbuf(stderr, NULL);
+  
   RPKI_SRV_Configuration config;
   memset(&config, 0, sizeof(RPKI_SRV_Configuration));
   // Initialize keyLocation
--- ./src/tools/rpkirtr_client.c	2017-07-05 12:29:08.000000000 -0400
+++ /opt/project/NIST-gitlab/srx-server/./src/tools/rpkirtr_client.c	2020-05-18 02:16:10.098963093 -0400
@@ -22,10 +22,30 @@
  * Connects to an RPKI/Router Protocol server and prints all received
  * information on stdout.
  *
- * @version 0.5.0.0
+ * @version 0.5.0.4
  *
  * Changelog:
  * -----------------------------------------------------------------------------
+ *  0.5.0.4 - 2018/03/09 - oborchert
+ *            * Do not print starting string on single run except if verbose is 
+ *              enabled.
+ *          - 2018/03/07 - oborchert
+ *            * Modified setting of st_verbose and st_debug. Also modified
+ *              logging according to the st_... values.
+ *          - 2018/03/06 - oborchert
+ *            * Renamed printReset and printPrefix into handle... 
+ *            * Added information if client can downgrade if protocol is 
+ *              larger than cache protocol.
+ *            * Added Program header printout.
+ *          - 2018/03/01 - oborchert
+ *            * BZ1264: Fixed define DEF_FMT_WD to correct default withdrawal 
+ *              formating.
+ *            * Added usage of readline to command for non single run.
+ *  0.5.0.3 - 2018/02/22 - oborchert
+ *            * Added version printout to program start.
+ *            * Fixed syntax printout.
+ *            * Moved some defines into rpki_router.h header file.
+ *            * Added rpki_packet_printer.h
  *  0.5.0.0 - 2017/06/29 - oborchert
  *            * Added end of data handler.
  *            * Modified pringHex and calls to it to not have compiler warnings.
@@ -50,17 +70,28 @@
 #include <stdarg.h>
 #include <errno.h>
 #include <string.h>
+#include <readline/readline.h>
+#include "shared/rpki_router.h"
+#include "server/rpki_packet_printer.h"
 #include "server/rpki_router_client.h"
 #include "util/log.h"
 #include "util/prefix.h"
 #include "util/io_util.h"
+#include "util/str.h"
 
 /** The default RPKI port (rfc6810) */
-#define DEF_RPKI_PORT  323
-#define DEF_RPKI_CACHE "localhost";
 #define DEF_FMT_AN "+ %u %s(%u)"
-#define DEF_FMT_WD "+ %u %s(%u)"
-#define RPKI_CONNECTION_TIMEOUT 3;
+#define DEF_FMT_WD "- %u %s(%u)"
+
+#define SRX_TOOLS_CACHE_CLIENT_NAME "RPKI Cache Client Tester"
+
+#define CMD_SERIAL_QUERY        's'
+#define CMD_RESET_QUERY         'r'
+#define CMD_QUIT_CLIENT         'q'
+#define CMD_HELP_CLIENT         'h'
+#define CMD_SEND_ERR_LAST_PD    'e'
+#define CMD_DEBUG_REC           '1'
+#define CMD_DEBUG_SND           '2'
 
 /**
  * Static parameter that specifies if this runs program in debug mode or not.
@@ -75,6 +106,18 @@ static bool st_debug   = false;
 static bool st_verbose = false;
 
 /**
+ * Static parameter to indicate if received packages to be printed.
+ * @since 0.5.0.4
+ */
+static bool st_print_receive = false;
+
+/**
+ * Static parameter to indicate if send packages to be printed.
+ * @since 0.5.0.4
+ */
+static bool st_print_send = false;
+
+/**
  * Static parameter that indicates if this program should only perform a single
  * request.
  *
@@ -94,37 +137,38 @@ static char st_add_format[256] = {DEF_FM
  * @since 0.5.0.0
  */
 static char st_del_format[256] = {DEF_FMT_WD "\n\0"};
+
 /*
  * RPKI/Router client handlers
  */
-void printPrefix(uint32_t valCacheID, uint16_t sessionID,
+void handlePrefix(uint32_t valCacheID, uint16_t sessionID,
                  bool isAnn, IPPrefix* prefix, uint16_t maxLen, uint32_t oas,
                  void* _u)
 {
   char prefixBuf[MAX_PREFIX_STR_LEN_V6];
 
-  if (st_debug)
+  if (isAnn)
   {
-    LOG(LEVEL_DEBUG, "[Prefix] %s (vcd=0x%08X sessionID=0x%04X): prefix=%s-%u, "
-                     "as=%u", (isAnn ? "Ann" : "Wd"), valCacheID, sessionID,
-                     ipPrefixToStr(prefix, prefixBuf, MAX_PREFIX_STR_LEN_V6),
-                     maxLen, oas);
-  }
-  else if (isAnn)
+    if (st_add_format[0] != 0)
   {
     printf (st_add_format, oas,
             ipPrefixToStr(prefix, prefixBuf, MAX_PREFIX_STR_LEN_V6), maxLen);
-  } else
+    }
+  } 
+  else
+  {
+    if (st_del_format[0] != 0)
   {
     printf (st_del_format, oas,
             ipPrefixToStr(prefix, prefixBuf, MAX_PREFIX_STR_LEN_V6), maxLen);
   }
 }
+}
 
 /**
  * Only adds a log entry
  */
-void printReset()
+void handleReset()
 {
   LOG(LEVEL_INFO, "Received a Cache Reset");
 }
@@ -210,7 +254,8 @@ void handleEndOfData(uint32_t valCacheID
 bool handleError(uint16_t errNo, const char* msg, void* _u)
 {
   LOG(LEVEL_ERROR, "Received an error [%u], msg='%s'", errNo, msg);
-  return errNo == 2; // Keep the connection only if not fatal
+  return errNo == RPKI_EC_NO_DATA_AVAILABLE; // Keep the connection only if not 
+                                             // fatal
 }
 
 /**
@@ -258,22 +303,35 @@ void sessionIDEstablished (uint32_t valC
  */
 void syntax(const char* prgName)
 {
-    printf ("syntax: %s [options] [<host> [<port>]]\n", prgName);
-    printf (" options: -hH?Dvs --help help\n");
-    printf ("   help, --help, -h, -H: This screen.\n");
-    printf ("     -D: enable debug output.\n");
-    printf ("     -D: enable debug output.\n");
-    printf ("     -v: verbose.\n");
-    printf ("     -s: perform only a single run.\n");
-    printf ("     -a <format>: The printout format for announcements.\n");
-    printf ("     -r <format>: The printout format for withdrawals.\n");
-    printf ("     -V <0|1>: version for rpki router client.\n");
+    printf ("\nSyntax: %s [options] [<host> [<port>]]\n\n", prgName);
+    printf (" Options:\n");
+    printf ("     -h, -H, -? --help\n"
+            "         This screen.\n");
+    printf ("     -D\n"
+            "         Enable debug output.\n");
+    printf ("     -v\n"
+            "         Verbose.\n");
+    printf ("     -pr\n"
+            "         Print receive.\n");
+    printf ("     -ps\n"
+            "         Print send.\n");
+    printf ("     -s\n"
+            "         Perform only a single run.\n");
+    printf ("     -a <format>\n"
+            "         The printout format for announcements.\n");
+    printf ("     -w <format>\n"
+            "         The printout format for withdrawals.\n");
+    printf ("     -V <0|1>\n"
+            "         Version for RPKI router client.\n");
+    printf ("     -d\n"
+            "         Allow downgrading to Version 0 (only for -V 1)\n\n");
     printf (" format:\n");
-    printf ("    The default format if \"%s\" for announcements and\n"
+    printf ("    The default format is \"%s\" for announcements and\n"
             "    \"%s\" for withdrawals.\n", DEF_FMT_AN, DEF_FMT_WD);
     printf ("    The order in which the data is printed is ASN, Prefix, Maxlen");
-    printf ("\n    This means the formating string must contain the order\n");
-    printf ("\n    integer - string - integer\n");
+    printf ("\n    This means the formating string must contain the order");
+    printf ("\n    integer - string - integer");
+    printf ("\n\n 2010-2018 ANTD NIST - Version %s\n", SRX_TOOLS_VERSION);
 }
 
 /**
@@ -293,28 +351,42 @@ bool parseParams(int argc, char** argv,
   char* arg    = NULL;
   bool  retVal = true;
   bool  doHelp = false;
+  // Determine if a parameter switch is provided
+  bool  pSwitch = false;
+  bool  isA     = false;
   int idx = 0;
 
   *exitVal = 0;
 
+  // serverhost MUST be NULL to indicate if it is set already
   params->serverHost = NULL;
+  // serverPort MUST be set to 0 to indicate if it is set already
   params->serverPort = 0;
-  params->version = 0;
+  // The protocol version to be used
+  params->version    = RPKI_RTR_PROTOCOL_VERSION;
 
-  for (idx = 1; (idx < argc) && !doHelp; idx++)
+  for (idx = 1; (idx < argc) && !doHelp && !*exitVal; idx++)
   {
     arg = (char*)argv[idx];
-    if (argv[idx][0] == '-')
-    {
-      // Move over the '-'
-      arg++;
-      if (strcmp(arg, "-help") == 0)
+    pSwitch = false;
+    
+    switch (arg[0])
       {
+      case '-' :
+        pSwitch = true;
+        break;
+      case '?' :
         doHelp = true;
+      default:
+        break;
       }
-      else
+    
+    if (pSwitch)
       {
-        bool isA = false;
+      // Move over the '-'
+      arg++;
+      isA = false;
+
         switch (arg[0])
         {
           case 'h':
@@ -322,31 +394,65 @@ bool parseParams(int argc, char** argv,
           case '?':
             doHelp = true;
             break;
+        case 'D':
+          // Add debug information
+          st_debug   = true;
+          // Debugging requires verbose to be enabled - no break here
           case 'v':
             // Add verbose information.
             st_verbose = true;
             break;
-          case 'D':
-            // Add debug information
-            st_debug = true;
+        case 'p':
+          if (strlen(arg) == 2)
+          {
+            if (arg[1] == 'r')
+            {
+              st_print_receive = true;
+            }
+            else if (arg[1] == 's')
+            {
+              st_print_send = true;
+            }
+          }
+          else
+          {
+            printf ("Error: Invalid print parameter '-%s'!\n", arg);
+            *exitVal = 1;            
+          }
             break;
           case 's':
             // Perform a single request only
             st_single_request = true;
             break;
-          case 'a':
-            isA = true;
           case 'V':
-            params->version= atoi(argv[2] );
-            idx++;
+          if (++idx < argc)
+          {
+            params->version= atoi(argv[idx]);
+          }
+          else
+          {
+            printf ("Error: Version 0|1 is missing!\n");
+            *exitVal = 1;
+            doHelp = true;
+          }
+          if (params->version > RPKI_RTR_PROTOCOL_VERSION)
+          {
+            printf ("Error: Invalid version number %u!\n", params->version);
+            *exitVal = 1;
+            doHelp = true;            
+          }
+          break;
+        case 'd':
+          params->allowDowngrade = true;
             break;
+        case 'a':
+          isA = true;
           case 'w':
             idx++;
             if (idx < argc)
             {
               arg = argv[idx];
-              if (isA) snprintf(st_add_format, 256, "%s\n", arg);
-              else     snprintf(st_add_format, 256, "%s\n", arg);
+            snprintf(isA ? st_add_format : st_del_format, 256, "%s\n", arg);
             }
             else
             {
@@ -355,19 +461,19 @@ bool parseParams(int argc, char** argv,
               *exitVal = 1;
             }
             break;
+        case '-':
+          if (strcmp(arg, "-help") == 0)
+          {
+            doHelp = true;
+            break;
+          }
           default:
             printf ("Invalid parameter '%s'\n", arg);
             doHelp = true;
+          *exitVal = 1;
             break;
         }
       }
-    }
-    else
-    {
-      if (strcmp(arg, "help") == 0)
-      {
-        doHelp = true;
-      }
       else
       {
         if (params->serverHost == NULL)
@@ -386,7 +492,6 @@ bool parseParams(int argc, char** argv,
         }
       }
     }
-  }
 
   if (doHelp)
   {
@@ -397,11 +502,11 @@ bool parseParams(int argc, char** argv,
   {
     if (params->serverHost == NULL)
     {
-      params->serverHost = DEF_RPKI_CACHE;
+      params->serverHost = RPKI_DEFAULT_CACHE;
     }
     if (params->serverPort == 0)
     {
-      params->serverPort = DEF_RPKI_PORT;
+      params->serverPort = RPKI_DEFAULT_CACHE_PORT;
     }
   }
 
@@ -429,26 +534,54 @@ int main(int argc, const char* argv[])
 
   client.stopAfterEndOfData = st_single_request;
 
+  // Retrieve program name out of the first program argument
+  char* realNamePtr = (char*)argv[0];
+  char* nextPtr = strstr(realNamePtr, "/");
+  while (nextPtr != NULL)
+  {
+    realNamePtr = nextPtr + 1;
+    nextPtr = strstr(realNamePtr, "/");
+  }
+  
+  if (!st_single_request || st_verbose)
+  {
+    printf ("Starting %s (%s) V%s\n", SRX_TOOLS_CACHE_CLIENT_NAME, realNamePtr,
+                                      SRX_TOOLS_VERSION);
+  }
+  
   // Print the configures settings.
   if (st_verbose)
   {
     printf ("Use Configuration RPKT/RTR:\n");
-    printf (" - Server...: %s\n", params.serverHost);
-    printf (" - Port.....: %i\n", params.serverPort);
+    printf (" - Server.........: %s\n", params.serverHost);
+    printf (" - Port...........: %i\n", params.serverPort);
+    printf (" - Version........: %i\n", params.version);
+    if (params.version > 0)
+    {
+      printf (" - Can Downgrade..: %s\n", params.allowDowngrade ? "on\0" 
+                                                                : "off\0");
+    }
   }
 
-  // Send all errors and debugging to stdout
-  setLogMethodToFile(st_debug ? stdout : NULL);
+  // if verbose is enabled log to stdout, otherwise drop it.
+  setLogMethodToFile(st_verbose ? stdout : NULL);
+  // set log-level.
+  setLogLevel(st_debug ? LEVEL_DEBUG : LEVEL_INFO);
 
   // Create a new client (establish connection, "Reset Query")
-  params.prefixCallback               = printPrefix;
-  params.resetCallback                = printReset;
+  params.prefixCallback               = handlePrefix;
+  params.resetCallback                = handleReset;
   params.errorCallback                = handleError;
   params.routerKeyCallback            = handleRouterKey;
   params.connectionCallback           = handleConnection;
   params.endOfDataCallback            = handleEndOfData;
   params.sessionIDChangedCallback     = sessionIDChanged;
   params.sessionIDEstablishedCallback = sessionIDEstablished;
+  // The following is a default PDU printer.
+  params.debugRecCallback             = st_print_receive 
+                                        ? doPrintRPKI_to_RTR_PDU : NULL;
+  params.debugSendCallback            = st_print_send
+                                        ? doPrintRPKI_to_RTR_PDU : NULL;
 
   if (!createRPKIRouterClient(&client, &params, NULL))
   {
@@ -480,32 +613,81 @@ int main(int argc, const char* argv[])
     {
       continue;
     }
-    do
-    {
       if (!st_single_request)
       {
-        printf (">> ");
+      char* line = readline(">> ");
+      if (line != NULL)
+      {
+        cmd = line[0];
+        free(line);
+        line=NULL;
       }
+    }
+    else 
+    {
+      do
+      {
       cmd = au_getchar(&client.stop, 0);
     } while (cmd == '\n');
+      printf ("\n");
+    }
 
     switch (cmd)
     {
-      case 's':
+      case CMD_SERIAL_QUERY:
+        printf ("\n");
         sendSerialQuery(&client);
         break;
-      case 'r':
+      case CMD_RESET_QUERY:
+        printf ("\n");
         sendResetQuery(&client);
         break;
-      case 'q':
+      case CMD_QUIT_CLIENT:
         doRun = false;
         break;
-      case 'h':
-        printf("s = Send Serial Query - Request all new PDU's\n"
-               "r = Send Reset Query  - Request all PDU's known to the cache\n"
-               "q = Quit the program\n"
-               "h = This screen\n"
-               "e = Send the last received PDU as error.\n");
+      case CMD_SEND_ERR_LAST_PD:
+        printf("Not implemented yet!\n");
+        break;
+      case CMD_DEBUG_REC:
+        if (params.debugRecCallback != NULL)
+        {
+          params.debugRecCallback = NULL;
+          printf ("Disabled debugging receiving PDUs\n");
+        }
+        else
+        {
+          params.debugRecCallback = doPrintRPKI_to_RTR_PDU;
+          printf ("Enable debugging receiving PDUs\n");          
+        }
+        break;
+      case CMD_DEBUG_SND:
+        if (params.debugSendCallback != NULL)
+        {
+          params.debugSendCallback = NULL;
+          printf ("Disabled debugging sending PDUs\n");
+        }
+        else
+        {
+          params.debugSendCallback = doPrintRPKI_to_RTR_PDU;
+          printf ("Enable debugging sending PDUs\n");          
+        }
+        break;
+      case CMD_HELP_CLIENT:
+        printf ("%c = Send Serial Query\n"
+                "    * Request all new PDU's\n", 
+                CMD_SERIAL_QUERY);
+        printf ("%c = Send Reset Query\n"
+                "    * Request all PDU's known to the cache\n", 
+                CMD_RESET_QUERY);
+        printf ("%c = Quit the program\n", CMD_QUIT_CLIENT);
+        printf ("%c = This screen\n", CMD_HELP_CLIENT);
+        printf ("%c = Send the last received PDU as error.\n",
+                CMD_SEND_ERR_LAST_PD);
+        printf ("%c = Toggle Printing of received messages (currently %s)\n",
+                CMD_DEBUG_REC, params.debugRecCallback != NULL ? "on"  : "off");
+        printf ("%c = Toggle Printing of send messages (currently %s)\n",
+               CMD_DEBUG_SND, params.debugSendCallback != NULL ? "on"  : "off");
+        printf ("\n");
       default:
         if (client.stop)
         {
--- ./src/client/client_connection_handler.h	2017-05-19 21:10:06.000000000 -0400
+++ /opt/project/NIST-gitlab/srx-server/./src/client/client_connection_handler.h	2020-05-18 02:16:10.078963121 -0400
@@ -20,10 +20,13 @@
  * other licenses. Please refer to the licenses of all libraries required 
  * by this software.
  *
- * Version 0.3.0.10
+ * Version 0.5.0.6
  * 
  * Changelog:
  * -----------------------------------------------------------------------------
+ * 0.5.0.6 - 2018/11/20 - oborchert
+ *           * Removed "inline" keyword from functions - caused linker error 
+ *             on Ubuntu 18
  * 0.3.0.10 - 2015/11/09 - oborchert
  *            * Removed types.h
  * 0.3.0    - 2013/02/27 - oborchert
@@ -154,7 +157,7 @@ void releaseClientConnectionHandler(Clie
  *
  * @return true if the wait could be executed, otherwise false.
  */
-inline bool connHandlerWait(ClientConnectionHandler* self);
+bool connHandlerWait(ClientConnectionHandler* self);
 
 /**
  * This method waits until data is received. It is expected that the lock is
@@ -164,7 +167,7 @@ inline bool connHandlerWait(ClientConnec
  *
  * @return true if the notify could be send, otherwise false.
  */
-inline bool connHandlerNotify(ClientConnectionHandler* self);
+bool connHandlerNotify(ClientConnectionHandler* self);
 
 /**
  * This method locks the mutex for wait and notification
@@ -173,7 +176,7 @@ inline bool connHandlerNotify(ClientConn
  *
  * @return true if the lock could be taken.
  */
-inline bool connHandlerLock(ClientConnectionHandler* self);
+bool connHandlerLock(ClientConnectionHandler* self);
 
 /**
  * This method unlocks the mutex for wait and notification
@@ -182,7 +185,7 @@ inline bool connHandlerLock(ClientConnec
  *
  * @return true if the lock could be removed.
  */
-inline bool connHandlerUnlock(ClientConnectionHandler* self);
+bool connHandlerUnlock(ClientConnectionHandler* self);
 
 /**
  * Sends a packet to the server.
--- ./src/server/rpki_router_client.h	2017-12-05 16:45:32.000000000 -0500
+++ /opt/project/NIST-gitlab/srx-server/./src/server/rpki_router_client.h	2020-05-18 02:16:10.091963103 -0400
@@ -29,9 +29,25 @@
  *
  * Changelog:
  * -----------------------------------------------------------------------------
- * 0.5.1.0  - 2017/10/13 - oborchert
+ * 0.5.1.0  - 2018/03/09 - oborchert 
+ *            * BZ1263: Merged branch 0.5.0.x (version 0.5.0.4) into trunk 
+ *              of 0.5.1.0.
+ *          - 2017/10/13 - oborchert
  *            * Removed keyword extern from functions in header file.
  *            * Removed backslash c from comments
+ * 0.5.0.4  - 2018/03/07 - oborchert
+ *            * Fixed speller in documentation.
+ *            * Removed 'extern' from functions. 
+ *            * Removed functions getLastSentPDUType and getLastReceivedPDUType.
+ *          - 2018/03/06 - oborchert
+ *            * Removed debugCallback of 0.5.0.3 by separating it into two 
+ *              individual functions 1:debugRecCallback and 2:debugSendCallback.
+ * 0.5.0.3  - 2018/02/26 - oborchert
+ *            * Added parameter allowDowngrade. (part of fix for BZ1261)
+ *            * Added function pointer debugCallback
+ *            * Added function doPrintRPKI_to_RTR_PDU
+ *          - 2018/02/23 - oborchert
+ *            * Modified RPKIRouterClientParams.version from int to u_int8_t
  * 0.5.0.0  - 2017/06/29 - oborchert
  *            * Added more documentation to function headers.
  *          - 2017/06/16 - kyehwanl
@@ -89,7 +105,8 @@ typedef struct {
    *                    cache state changes.
    * @param sessionID   The cache sessionID entry for this data. It is be useful
    *                    for sessionID changes in case SRx is implementing a
-   *                    performance driven approach.
+   *                    performance driven approach. This ID does not come from 
+   *                    the prefix PDU, it is the stored value in the client.
    * @param isAnn       Indicates if this in an announcement or not.
    * @param prefix      The prefix itself. Contains the information of v4/v6
    * @param maxLen      the maximum length this white-list / ROA entry covers.
@@ -188,11 +205,26 @@ typedef struct {
    * @param errNo Error number all except 2 are fatal
    * @param msg Error message
    * @param user User data
-   * @return true = keep the connection, false = close connection
+   * @return \c true = keep the connection, \c false = close connection
    */
   bool (*errorCallback)(uint16_t errNo, const char* msg, void* user);
 
   /**
+   * An erroneous PDU was received.
+   * 
+   * @note Optional - can be NULL
+   * 
+   * @param len Length of the erroneous PDU
+   * @param erronPDU The erroneus PDU
+   * @param user USer Data
+   * 
+   * @return true = keep the connection, false = close the connection
+   * 
+   * @since 0.5.0.3
+   */
+  bool (*erronPDUCallback)(u_int32_t len, u_int8_t* erronPDU, void* user);
+
+  /**
    * The connections was lost. The client will try to reconnect.
    *
    * @note Optional - can be NULL
@@ -204,12 +236,44 @@ typedef struct {
   int (*connectionCallback)(void* user);
   // Server connection
 
+  /**
+   * Allows to perform a debug callback prior processing the received PDU.
+   * 
+   * @note Optional - can be NULL
+   * 
+   * @param *user User data (commonly the client implementation itself
+   * @param *pdu The received PDU
+   * 
+   * @return false if the PDU has a syntax or logical error.
+   * 
+   * @since 0.5.0.4
+   */
+  bool (*debugRecCallback)(void* user, RPKICommonHeader* pdu);  
+
+    /**
+   * Allows to perform a debug callback prior processing the received PDU.
+   * 
+   * @note Optional - can be NULL
+   * 
+   * @param *user User data (commonly the client implementation itself
+   * @param *pdu The received PDU
+   * 
+   * @return false if the PDU has a syntax or logical error.
+   * 
+   * @since 0.5.0.4
+   */
+  bool (*debugSendCallback)(void* user, RPKICommonHeader* pdu);  
+
   /** Set this variable to the server host name - not IP. */
   const char* serverHost;
   /** Set this variable to the server port number. */
   int         serverPort;
-  /* rpki version info */
-  int         version;
+  /** rtr-to-cache version info */
+  u_int8_t    version;
+  /** Allow downgrading to lower version number if signaled during session 
+   * negotiation. 
+   * @since 0.5.0.3 */
+  bool        allowDowngrade;
 } RPKIRouterClientParams;
 
 /**
@@ -218,21 +282,22 @@ typedef struct {
  * @note Do not modify any of the variables!
  */
 typedef struct {
-  /** This id MUST be unique within the application. */
-  uint8_t                  routerClientID;
+  /** This id MUST be unique within the application. It is the ID that 
+   *  identifies the cache. */
+  uint32_t                routerClientID;
 
-  /** The Parameters of this clinet */
+  /** The Parameters of this client */
   RPKIRouterClientParams*  params;
   /** */
   void*                    user;
 
-  /** The socet information. */
+  /** The socket information. */
   ClientSocket             clSock;
-  /** Indicates if the sonnection is stopped. */
+  /** Indicates if the connection is stopped. */
   bool                     stop;
   /** The worker thread for this connection. */
   pthread_t                thread;
-  /** The rwite mutex of this connection. */
+  /** The write mutex of this connection. */
   Mutex                    writeMutex;
   /** The last used serial number for this connection (in network order!). */
   uint32_t                 serial; // < Stored in network order
@@ -258,14 +323,14 @@ typedef struct {
    * without continuous polling.
    * @since 0.5.0.0 */
   bool                     stopAfterEndOfData;
-  /* rpki version info */
+  /** RTR-to-Cache protocol version info */
   int8_t                   version;
 } RPKIRouterClient;
 
 /**
  * Create a unique router client ID
  *
- * @param self the router clinet the ID has to be generated for.
+ * @param self the router client the ID has to be generated for.
  *
  * @return the ID;
  */
@@ -280,8 +345,8 @@ uint32_t createRouterClientID(RPKIRouter
  * @param self Client variable that will be initialized.
  * @param params Pre-set parameters.
  * @param routerClientID an ID that will be assigned to this RPKIRouterClient.
- * @param user User data - will be passed to the call-backs
- * @return true = successful, false = something failed
+ * @param user User data - will be passed to the callback functions
+ * @return \c true = successful, \c false = something failed
  */
 bool createRPKIRouterClient(RPKIRouterClient* client,
                             RPKIRouterClientParams* params,
@@ -311,21 +376,24 @@ bool sendResetQuery(RPKIRouterClient* cl
 bool sendSerialQuery(RPKIRouterClient* client);
 
 /**
- * Returns the type of the last sent PDU.
+ * Send an error report to the server.
  *
- * @param client Client instance
- * @return Type
- */
-RPKIRouterPDUType getLastSentPDUType(RPKIRouterClient* client);
-
-/**
- * Returns the type of the last received PDU.
+ * @param self the instance of RPKI router client.
+ * @param errCode The error code to be used.
+ * @param erronPDU The PDU containing the error.
+ * @param lenErronPDU Length of the erroneous PDU.
+ * @param errText The administrative text message that accompanies the error.
+ * @param lenErrText The length of the text string.
  *
- * @param client Client instance
- * @return Type
+ * @return true if the packet could be send successfully.
+ * 
+ * @since 0.5.0.3
  */
-RPKIRouterPDUType getLastReceivedPDUType(RPKIRouterClient* client);
+bool sendErrorReport(RPKIRouterClient* self, u_int16_t errCode,
+                            u_int8_t* erronPDU, u_int32_t lenErronPDU,
+                            char* errText, u_int32_t lenErrText);
 
+// @TODO: fix this not so nice work around
 int g_rpki_single_thread_client_fd;
 
 void generalSignalProcess(void);
--- ./src/server/command_queue.h	2017-05-19 21:10:06.000000000 -0400
+++ /opt/project/NIST-gitlab/srx-server/./src/server/command_queue.h	2020-05-18 02:16:10.087963108 -0400
@@ -20,16 +20,19 @@
  * other licenses. Please refer to the licenses of all libraries required 
  * by this software.
  *
- * @version 0.3.0
+ * @version 0.5.0.6
  *
  * Changelog:
  * -----------------------------------------------------------------------------
- *   0.3.0 - 2013/02/06 - oborchert
+ *   0.5.0.6 - 2018/11/20 - oborchert
+ *             * Removed "inline" keyword from functions - caused linker error 
+ *               on Ubuntu 18
+ *   0.3.0.0 - 2013/02/06 - oborchert
  *           * Added Version Control
  *           * Changed log level of output during shutdown
- *   0.2.0 - 2011/11/01 - oborchert
+ *   0.2.0.0 - 2011/11/01 - oborchert
  *           * Rewritten.
- *   0.1.0 - 2010/05/05 - pgleichm
+ *   0.1.0.0 - 2010/05/05 - pgleichm
  *           * Code Created
  * -----------------------------------------------------------------------------
  */
@@ -148,7 +151,7 @@ void removeAllCommands(CommandQueue* sel
  * 
  * @return the maximum number of items in the queue.
  */
-inline int getTotalQueueSize(CommandQueue* self);
+int getTotalQueueSize(CommandQueue* self);
 
 /**
  * Return the number of unprocessed commands in the queue
@@ -157,6 +160,6 @@ inline int getTotalQueueSize(CommandQueu
  * 
  * @return the number of unprocessed items in the queue.
  */
-inline int getUnprocessedQueueSize(CommandQueue* self);
+int getUnprocessedQueueSize(CommandQueue* self);
 #endif // !__COMMAND_QUEUE_H__
 
--- ./src/server/console.c	2017-12-05 16:45:32.000000000 -0500
+++ /opt/project/NIST-gitlab/srx-server/./src/server/console.c	2020-05-18 02:16:10.088963107 -0400
@@ -20,10 +20,15 @@
  * other licenses. Please refer to the licenses of all libraries required
  * by this software.
  *
- * @version 0.5.0.1
+ * @version 0.5.0.6
  *
  * Changelog:
  * -----------------------------------------------------------------------------
+ * 0.5.0.6 - 2018/11/20 - oborchert
+ *           * Added missing header file.
+ * 0.5.0.3  - 2018/02/23 - oborchert
+ *            * BZ1223: Resolved compiler warning. Added TODO into code where
+ *              revisit is necessary.
  * 0.5.0.1  - 2017/08/29 - oborchert
  *            * BZ1225: Function doShowCount did not use the correct internal 
  *              commands.
@@ -70,6 +75,7 @@
 #include <string.h>
 #include <signal.h>
 
+#include "server/command_queue.h"
 #include "server/configuration.h"
 #include "server/console.h"
 #include "server/prefix_cache.h"
@@ -1554,7 +1560,8 @@ static void doShowUpdate(SRXConsole* sel
   {
     //SRxUpdateID updateID = atoll(showParam);
     SRxUpdateID updateID = hexToInt(showParam);
-    doShowCount(self, &updateID);
+    // TODO: Fix doShowCount call of incorrect data size 
+    doShowCount(self, (char*)&updateID);
   }
   else
   {
--- ./src/server/srx_server.h	2017-05-19 21:10:06.000000000 -0400
+++ /opt/project/NIST-gitlab/srx-server/./src/server/srx_server.h	2020-05-18 02:16:10.094963099 -0400
@@ -21,10 +21,13 @@
  *
  * This file does provide CONSTANT declarations ONLY
  *
- * Version 0.3.1.0
+ * Version 0.5.0.7
  * 
  * Changelog:
  * -----------------------------------------------------------------------------
+ * 0.5.0.7 - 2018/11/30 - oborchert
+ *         * Removed SRX_REVISION framework. Does not work with GIT and is not
+ *           needed anymore due to correct version numbering of the code.
  * 0.3.1.0 - 2015/11/11 - oborchert
  *         * Fixed speller in program name from SRX to SRx
  * 0.3.0.7 - 2015/04/21 - oborchert
@@ -55,22 +58,10 @@
 #define SRX_SERVER_PACKAGE  "NA"
 #endif
 
-// Compiler setting -D SRX_REVISION
-#ifdef SRX_REVISION
-  #if (SRX_CHECKVAL(SRX_REVISION) == 1)
-    // SRX_REVISION is empty -> discard it
-    #define SRX_SERVER_REVISION ""    
-  #else
-    #define SRX_SERVER_REVISION SRX_STRINGIFY_IND(SRX_REVISION)
-  #endif
-#else
-  #define SRX_SERVER_REVISION ""
-#endif
-
 // Used version number -  make a string of the define
 #define SRX_SERVER_VERSION  SRX_STRINGIFY_IND(SRX_SERVER_PACKAGE)
 // Used full version number
-#define SRX_SERVER_FULL_VER SRX_SERVER_VERSION SRX_SERVER_REVISION
+#define SRX_SERVER_FULL_VER SRX_SERVER_VERSION
 
 #define SRX_CREDITS "This program was developed at the National Institute "  \
                 "of Standards and Technology (NIST - www.nist.gov) in "      \
--- ./src/server/rpki_router_client.c	2017-12-05 16:45:32.000000000 -0500
+++ /opt/project/NIST-gitlab/srx-server/./src/server/rpki_router_client.c	2020-05-18 02:16:10.091963103 -0400
@@ -26,9 +26,32 @@
  *
  * Changelog:
  * -----------------------------------------------------------------------------
- * 0.5.1.0  - 2017/10/13 - oborchert
+ * 0.5.1.0  - 2018/03/09 - oborchert 
+ *            * BZ1263: Merged branch 0.5.0.x (version 0.5.0.4) into trunk 
+ *              of 0.5.1.0.
+ *          - 2017/10/13 - oborchert
  *            * Temporarily modified hard coded return value of function 
  *              createRouterClientID from 0 to 1.
+ * 0.5.0.5  - 2018/05/17 - oborchert
+ *            (merged from branch 0.5.0.x)
+ *          - 2018/04/24 - oborchert
+ *            * Added missing code in error handling.
+ * 0.5.0.4  - 2018/03/07 - oborchert
+ *            * Modified packet handling and added proper error handling and
+ *              version handshake, 
+ *            * Added internal error defines (RRC_.....)
+ *            * Completed missing documentation.
+ *            * Added documentation and removed inline from getLastSendPDU and 
+ *              getLastReceivedPDU.
+ *            * Fixed incorrect error code printing and streamlined the code in 
+ *              method method handleErrorReport (-1 return value was rubbish).
+ *            * Removed functions getLastSentPDUType and getLastReceivedPDUType
+ * 0.5.0.3  - 2018/02/26 - oborchert
+ *            * Added function wrapper _sendPDU to encapsulate allow debugging
+ *              debugging of sending packets.
+ *            * Added rpki_packet_printer header file.
+ *          - 2018/02/23 - oborchert
+ *            * Removed unnecessary code form sendResetQuery
  * 0.5.0.1  - 2017/10/01 - oborchert
  *            * Fixed compiler warning
  * 0.5.0.0  - 2017/06/29 - oborchert
@@ -69,6 +92,7 @@
 #include <signal.h>
 #include "server/rpki_queue.h"
 #include "server/rpki_router_client.h"
+#include "server/rpki_packet_printer.h"
 #include "util/client_socket.h"
 #include "util/log.h"
 #include "util/socket.h"
@@ -77,12 +101,23 @@
 
 #define HDR "([0x%08X] RPKI Router Client): "
 
+// Error codes for function receive PDU
+#define RRC_RCV_PDU_NO_ERROR     -1
+#define RRC_RCV_PDU_SOCKET_ERROR -2
+#define RRC_RCV_PDU_MEMORY_ERROR -3
+
+// Define a default string length
+#define RRC_MAX_STRING 255
+// Maximum errors during PDU processing
+#define RRC_MAX_ERRCT  10
+
 /**
  * Handle received IPv4 Prefixes.
  *
  * @param client The router client instance.
  * @param hdr the IPv4 prefix header.
- * @return
+ * 
+ * @return true if the IPv4 prefix could be properly processed.
  */
 static bool handleIPv4Prefix(RPKIRouterClient* client,
                              RPKIIPv4PrefixHeader* hdr)
@@ -141,12 +176,15 @@ static bool handleIPv6Prefix(RPKIRouterC
 }
 
 /**
- * Handles the receipt of an error pdu. The encapsulated PDU is ignored,
- * the error message will be printed though.
+ * This function is a wrapper for handling the received error pdu. 
+ * In case the client does not provide an additional error handler, this
+ * function will print the received error code, the error message and return
+ * the specified return values according to the quick processing of the packet. 
+ *
+ * @param client This client
+ * @param hdr The received error PDU
  *
- * @param client Client
- * @param hdr PDU header
- * @return \c 0 = stay connected, \c 1 = disconnect, \c -1 = socket error
+ * @return 0: stay connected, 1: disconnect
  */
 static int handleErrorReport(RPKIRouterClient* client,
                              RPKIErrorReportHeader* hdr)
@@ -154,40 +192,29 @@ static int handleErrorReport(RPKIRouterC
   uint32_t epduLen = ntohl(hdr->len_enc_pdu);
   // Go to the message portion
   uint8_t* messagePtr = (uint8_t*)hdr+12+epduLen;
-  // Set the messageLen
+  // Retrieve the messageLen
   uint32_t msgLen = ntohl(*(uint32_t*)messagePtr);
-  char     msgStr[msgLen+1];
-  int returnVal = (hdr->error_number == 2) ? 0 : 1; // all except 2 are fatal!
+  char      errorStr[msgLen+1];
+  u_int16_t error_number = ntohs(hdr->error_number);
 
-  // Zero terminate message String
-  msgStr[msgLen] = '\0';
-  // read the Message:
-  int idx=0;
-  // fill the string
-  for (;idx < msgLen; idx++)
-  {
-    msgStr[idx] = *(messagePtr+4+idx);
-  }
-  // Read the error pdu
+  // all except RPKI_EC_NO_DATA_AVAILABLE (2) are fatal!
+  int returnVal = (error_number == RPKI_EC_NO_DATA_AVAILABLE) ? 0 : 1; 
 
+  //Initialize and fill the message String
+  memset (errorStr, '\0', msgLen+1);
+  messagePtr += 4;
+  memcpy (errorStr, messagePtr, msgLen);
 
   if (client->params->errorCallback != NULL)
   {
     // Pass the code and message to the error callback of this connection
-    if (client->params->errorCallback(ntohs(hdr->error_number), msgStr,
-                                      client->user))
-    {
-      returnVal = 0;
+    returnVal = (client->params->errorCallback(error_number, errorStr, 
+                                               client->user)) ? 0 : 1;
     }
     else
     {
-      returnVal = 1;
-    }
-  }
-  else
-  {
-    LOG(LEVEL_INFO, "ERROR RECEIVING ERROR-PDU type:%d!", hdr->error_number);
-    returnVal = -1;
+    LOG(LEVEL_INFO, "ERROR RECEIVING ERROR-PDU type:%d, msg:'%s'!", 
+                    error_number, errorStr);
   }
 
   return returnVal;
@@ -244,6 +271,38 @@ static void handleEndOfData(RPKIRouterCl
 }
 
 /**
+ * This function checks the version number between the client and the cache.
+ * If the session is still in negotiation stage and the client can downgrade to
+ * successfully negotiate the session, the client version number will be 
+ * downgraded. If not and the versions differ this function returns false.
+ * 
+ * @param client This client. 
+ * @param version The version of the peer
+ * 
+ * @return true if the communication can be continued.
+ * 
+ * @since 0.5.0.3
+ */
+static bool checkVersion(RPKIRouterClient* client, u_int8_t version)
+{
+  if (client->version != version)
+  {
+    // Check the startup stage
+    if (client->startup)
+    {
+      // In case client(self) has a higher version than the requested one
+      // but can downgrade, then downgrade to peers version.
+      if (  (client->version > version) && client->params->allowDowngrade)
+      {
+        client->version = version;
+      }
+    }
+  }
+  
+  return client->version == version;
+}
+
+/**
  * Verify that the cache session id is correct. In case the cache session id is
  * incorrect == changed the flag session id_changed will be set to true. The old
  * session id value will be preserved to allow referencing old values.
@@ -279,68 +338,59 @@ static bool checkSessionID(RPKIRouterCli
 }
 
 /**
- * This method implements the receiver thread between the RPKI client and
- * RPKI server. It reads each PDU completely.
+ * Read the next packet from the socket into the provided buffer. In case the 
+ * buffer is not of sufficient size, the buffer will be extended.
  *
- * @param client The client connection to the RPKI router.
- * @param returnAterEndOfData Allows to exit the function once an end of data
- *                            is received. This is used during cache session id
- *                            change where the cache is reloaded.
+ * In case of an internal error receiving the PDU the returned length can be 
+ * less then the length field of the PDU indicates. In this case the errCode
+ * contains an erorr.
+ * 
+ * The following errors can be reported:
+ * 
+ *     RRC_RCV_PDU_NO_ERROR:       No error
+ *     RRC_RCV_PDU_SOCKET_ERROR:   Somehwo not all data could be loaded.
+ * 
+ * @param client The client session
+ * @param errCode Returns the error code.
+ * @param buffer The buffer to be filled.
+ * @param buffSize The max size of the buffer.
+ * 
+ * @return 0 or the number of bytes received (can be less then the PDU length).
  */
-static void receivePDUs(RPKIRouterClient* client, bool returnAterEndOfData)
+static u_int32_t _getPacket(RPKIRouterClient* client, int* errCode, 
+                            uint8_t** buffer, uint32_t* buffSize)
 {
-  RPKICommonHeader* hdr;  // A pointer to the Common header.
-  uint32_t          pduLen;
-  uint8_t*          byteBuffer;
-  uint8_t*          bufferPtr;
-  uint32_t          bytesMissing;
-  // Use the "maximum" header. It can grow in case an error pdu is received
-  // with a large error message or a PDU included or both. In this case the
-  // memory will be extended to the space needed. In case the space can not be
-  // extended, the PDU will be loaded as much as possible and the rest will be
-  // skipped.
-  uint32_t         bytesAllocated = sizeof(RPKIRouterKeyHeader);
-  // Keep going is used to keep the received thread up and running. It will be
-  // set false once the connection is shut down.
-  bool             keepGoing = true;
+  uint32_t pduLen       = 0;
+  uint32_t bytesMissing = 0;
+  uint8_t* bufferPtr    = *buffer + sizeof(RPKICommonHeader);
+  RPKICommonHeader* hdr = (RPKICommonHeader*)*buffer;
+  
+  // Initialize the values.
+  memset (*buffer, 0, *buffSize);
+  *errCode = RRC_RCV_PDU_NO_ERROR;
 
-  // Allocate the message buffer
-  byteBuffer = malloc(bytesAllocated);
-  // Set the bufferPtr to the position where the remaining data has be loaded
-  // into.
-  bufferPtr = (byteBuffer + sizeof(RPKICommonHeader));
-  if (!byteBuffer)
-  {
-    RAISE_ERROR("Could not allocate enough memory to read from socket!");
-    return;
-  }
-
-  // KeepGoing until a cache session id changed / in case of connection loss,
-  // a break stops this while loop.
-  while (keepGoing)
-  {
     // Read the common data for the Common header. This method fails in case the
     // connection is lost.
-    if (!recvNum(getClientFDPtr(&client->clSock), byteBuffer,
+  if (!recvNum(getClientFDPtr(&client->clSock), *buffer,
                  sizeof(RPKICommonHeader)))
     {
       LOG(LEVEL_DEBUG, HDR "Connection lost!", pthread_self());
-      break;
+    *errCode  = RRC_RCV_PDU_SOCKET_ERROR;
     }
-
-    hdr = (RPKICommonHeader*)byteBuffer;
+  else
+  {
     // retrieve the actual size of the message. In case more needs to be loaded
     // it will be done.
     pduLen = ntohl(hdr->length);
     if (pduLen < sizeof(RPKICommonHeader))
     {
-      LOG(LEVEL_DEBUG, HDR "Received an invalid RPKI-RTR PDU!", pthread_self());
-      break;
+      LOG(LEVEL_DEBUG, HDR "Corrupted RPKI-RTR PDU: Size!", pthread_self());
+      *errCode  = RPKI_EC_CORRUPT_DATA;
+    }    
     }
-    LOG(LEVEL_DEBUG, HDR "Received RPKI-RTR PDU[%d]", pthread_self(),
-                     hdr->type);
 
-/////////////////////////////////////////
+  if (*errCode == RRC_RCV_PDU_NO_ERROR)
+  {      
     // Determine how much data is still missing
     bytesMissing = pduLen - sizeof(RPKICommonHeader);
 
@@ -348,64 +398,209 @@ static void receivePDUs(RPKIRouterClient
     if (bytesMissing > 0)
     {
       // Check if the current buffer is big enough
-      if (bytesMissing > bytesAllocated)
+      if (bytesMissing > *buffSize)
       {
         // The current buffer is to small -> try to increase it.
-        uint8_t* newBuffer = realloc(byteBuffer, bytesMissing);
+        uint8_t* newBuffer = realloc(*buffer, *buffSize);
         if (newBuffer)
         {
-          byteBuffer = newBuffer; // reset to the bigger space
-          bytesAllocated = bytesMissing;
-          bufferPtr = (byteBuffer + sizeof(RPKICommonHeader));
+          *buffer   = newBuffer; // reset to the bigger space
+          *buffSize = bytesMissing;
+          bufferPtr = (*buffer + sizeof(RPKICommonHeader));
         }
         else
         {
           // can only happen in case it is an error packet that contains an
           // erroneous PDU or extreme large error text.
-          RAISE_ERROR("Invalid PDU length : type=%d, length=%u, data-size=%u",
-                      hdr->type, pduLen, bytesMissing);
+          LOG(LEVEL_ERROR, "Invalid PDU length : type=%d, length=%u, "
+                           "data-size=%u", hdr->type, pduLen, bytesMissing);
 
-          // Skip over the data
+          // Try to skip over the data
           if (!skipBytes(&client->clSock, bytesMissing))
           {
-            break;
+            LOG(LEVEL_ERROR, "While reading a corrupted PDU, could not skip "
+                             "over the remainig data");
           }
+          *errCode = RPKI_EC_CORRUPT_DATA;
         }
       }
 
       // Now load the remaining data
+      if (*errCode == RRC_RCV_PDU_NO_ERROR)
+      {
       if (!recvNum(getClientFDPtr(&client->clSock), bufferPtr, bytesMissing))
       {
-        break;
+          *errCode = RRC_RCV_PDU_SOCKET_ERROR; 
+          pduLen -= bytesMissing;
       }
     }
-/////////////////////////////////////////
-    client->lastRecv = hdr->type;
+    }
+  }
+  
+  return pduLen;
+}
+
+/**
+ * This method implements the receiver loop between the RPKI client and
+ * RPKI server. It reads and processes each PDU completely. It does NOT 
+ * close the socket on return.
+ * 
+ * The following error codes can be returned:
+ *   RPKI_EC_...: All RPKI error codes 0..255
+ *   RRC_RCV_PDU_NO_ERROR:     No Error
+ *   RRC_RCV_PDU_SOCKET_ERROR: Socket Error
+ *   RRC_RCV_PDU_MEMORY_ERROR: Memory Error
+ *
+ * @param client The client connection to the RPKI router.
+ * @param returnAterEndOfData Allows to exit the function once an end of data
+ *                            is received. This is used during cache session id
+ *                            change where the cache is reloaded.
+ * @param errCode -3: Memory Error, -2: Socket error, -1: NO ERROR, 
+ *                0..n RPKI_EC_... errors
+ * @param singlePoll if true only one single packet will be processed. This 
+ *                   allows to properly process a handshake.
+ * 
+ * @return true if all went well, false if an ERROR occurred.
+ */
+static bool receivePDUs(RPKIRouterClient* client, bool returnAterEndOfData, 
+                        int* errCode, bool singlePoll)
+{
+  RPKICommonHeader* hdr        = NULL;  // A pointer to the Common header.
+  uint32_t          pduLen     = 0;
+  // Use the "maximum" header. It can grow in case an error pdu is received
+  // with a large error message or a PDU included or both. In this case the
+  // memory will be extended to the space needed. In case the space can not be
+  // extended, the PDU will be loaded as much as possible and the rest will be
+  // skipped.
+  uint32_t         bytesAllocated = sizeof(RPKIRouterKeyHeader);
+  uint8_t*         byteBuffer = malloc(bytesAllocated);
+  // Keep going is used to keep the received thread up and running. It will be
+  // set false once the connection is shut down.
+  bool             keepGoing   = !client->stop;
+  
+  if (byteBuffer != NULL)
+  {
+    // Reset the error code to NO ERROR
+    *errCode = RRC_RCV_PDU_NO_ERROR;
+  }
+  else
+  {
+    RAISE_ERROR("Could not allocate enough memory to read from socket!");
+    *errCode  = RRC_RCV_PDU_MEMORY_ERROR;
+    keepGoing = false;
+  }
+
+  // KeepGoing until a cache session id changed / in case of connection loss,
+  // a break stops this while loop.
+  while (keepGoing && !client->stop)
+  {
+    // If singlePoll is selected, stop after this poll.
+    keepGoing = !singlePoll;
+    
+    pduLen = _getPacket(client, errCode, &byteBuffer, &bytesAllocated);
+    if (!pduLen)
+    {
+      keepGoing = false;
+      continue;
+    }
+    hdr = (RPKICommonHeader*)byteBuffer;
 
     LOG(LEVEL_DEBUG, HDR "Received RPKI-RTR PDU[%u] length=%u\n",
                      pthread_self(), hdr->type, ntohl(hdr->length));
 
-    // Is needed in PDU_TYPE_ERROR_REPORT
-    int ret;
+    // This is for printing received PDU's
+    if (client->params->debugRecCallback != NULL)
+    {
+      printf ("Received Packet:\n");
+      client->params->debugRecCallback(client, hdr);
+    }
+    
+    // Check if a version conflict exist. During negotiation this method might 
+    // downgrade the protocol.
+    if (!checkVersion(client, hdr->version))
+    {
+      // Check if the cache has a higher unsupported version or if the
+      // cache or client only supports version 0. In both cases use 
+      // UNSUPPORTED, otherwise use UNEXPECTED (version 1+)
+      *errCode = ((hdr->version > RPKI_RTR_PROTOCOL_VERSION)
+                  || (client->version == 0))
+                 ? RPKI_EC_UNSUPPORTED_PROT_VER
+                 : RPKI_EC_UNEXPECTED_PROTOCOL_VERSION;
+      
+      // the router and cache might still be in handshake
+      if (client->startup)
+      {
+        // Still in session establishment RFC8210 Section 7
+        // Following RFC 8210 Section 7 the cache responded with a lower version.        
+        if (client->params->allowDowngrade)
+        {
+          // 1st. let us downgrade and then decide what to do next.
+          LOG(LEVEL_NOTICE, "Cache responded with a version %u PDU, the "
+                            "'router' can downgrade.", hdr->version);
+          client->version = hdr->version;
+          
+          // 2nd, check if we can continue processing or if we need to stop 
+          // here.
+        }
+        else
+        {
+          LOG(LEVEL_NOTICE, "Cache responded with a version %u PDU, the "
+                            "'router' cannot downgrade.", hdr->version);
+        }
+        
+        // In case the cache did not respond with an error PDU, let's accept 
+        // this PDU by clearing the error and continue processing.
+        if (hdr->type != PDU_TYPE_ERROR_REPORT)
+        {
+          *errCode = RRC_RCV_PDU_NO_ERROR;
+        }
+      }
+      
+      // Error is not cleared, register the PDU as last received and end loop
+      if (*errCode != RRC_RCV_PDU_NO_ERROR)
+      {
+        // Stop loop of receiving data
+        client->lastRecv = hdr->type;
+        keepGoing = false;
+        continue;
+      }  
+    }
 
     // Handle the data depending on the type
+    u_int32_t sessionID = 0;
     switch (hdr->type)
     {
       case PDU_TYPE_SERIAL_NOTIFY :
         // Respond with a serial query
-        if (checkSessionID(client, ((RPKISerialNotifyHeader*)hdr)->sessionID))
+        sessionID = ((RPKISerialNotifyHeader*)hdr)->sessionID;
+        if (checkSessionID(client, sessionID))
         {
           sendSerialQuery(client);
         }
         else
         {
+          // incorrect session ID 
           keepGoing = false;
+          *errCode = RPKI_EC_CORRUPT_DATA;
         }
         break;
       case PDU_TYPE_CACHE_RESPONSE :
-        keepGoing = checkSessionID(client,
-                               ((RPKICacheResponseHeader*)hdr)->sessionID);
-        // No need to do anything
+        sessionID = ((RPKICacheResponseHeader*)hdr)->sessionID;
+        if (!checkSessionID(client, sessionID))
+        {
+          client->sessionIDChanged = true;
+          // Mark the clients cache DB as stale.
+          client->params->sessionIDChangedCallback(client->routerClientID, 
+                                                   sessionID);
+          // @TODO: Fix Session ID. 
+          // Only in case the previous message was a "Request Query" the session
+          // ID is allowed to change. RFC8210 5.5 2nd paragraph
+          if (client->lastSent != PDU_TYPE_CACHE_RESET)
+          {
+            keepGoing = false;
+            *errCode = RPKI_EC_CORRUPT_DATA;
+          }
+        }
         break;
       case PDU_TYPE_IP_V4_PREFIX :
         handleIPv4Prefix(client, (RPKIIPv4PrefixHeader*)byteBuffer);
@@ -414,21 +609,33 @@ static void receivePDUs(RPKIRouterClient
         handleIPv6Prefix(client, (RPKIIPv6PrefixHeader*)byteBuffer);
         break;
       case PDU_TYPE_END_OF_DATA :
-        if (checkSessionID(client, ((RPKIEndOfDataHeader*)hdr)->sessionID))
+        sessionID = ((RPKIEndOfDataHeader*)hdr)->sessionID;
+        if (checkSessionID(client, sessionID))
         {
           // store not byte-swapped
           client->serial = ((RPKIEndOfDataHeader*)byteBuffer)->serial;
           // Now process the RPKI_QUEUE
           handleEndOfData(client, (RPKIEndOfDataHeader*)byteBuffer);
+          // Stop the client is only one data poll is to be done.
+          // Replace client-stop with keepGoing
           keepGoing = !returnAterEndOfData;
         }
         else
         {
           keepGoing = false;
+          *errCode  = RPKI_EC_CORRUPT_DATA; 
         }
         break;
       case PDU_TYPE_ROUTER_KEY:
+        if (client->version != 0)
+        {
         handlePDURouterKey(client, (RPKIRouterKeyHeader*)byteBuffer);
+        }
+        else
+        {
+          *errCode = RPKI_EC_UNSUPPORTED_PDU;
+          keepGoing = false;
+        }
         break;
       case PDU_TYPE_CACHE_RESET :
         // Reset our cache
@@ -437,29 +644,118 @@ static void receivePDUs(RPKIRouterClient
         sendResetQuery(client);
         break;
       case PDU_TYPE_ERROR_REPORT :
-        ret = handleErrorReport(client, (RPKIErrorReportHeader*)byteBuffer);
-        if (ret != 0)
+        // Switched from client-stop to keepGoing
+        keepGoing = !handleErrorReport(client, 
+                                       (RPKIErrorReportHeader*)byteBuffer);
+        break;
+      case PDU_TYPE_RESERVED :
+        LOG(LEVEL_ERROR, "Received reserved RPKI-PDU Type %u", 
+            PDU_TYPE_RESERVED);
+        *errCode  = RPKI_EC_UNSUPPORTED_PDU;
+        keepGoing = false;
+        break;
+      default :
+        // We handled all known types already
+        LOG(LEVEL_ERROR, "Unsupported RPKI-PDU Type %u", hdr->type);
+        *errCode  = RPKI_EC_UNSUPPORTED_PDU;
+        keepGoing = false;
+    }
+    // Set the last received PDU
+    client->lastRecv = hdr->type;
+  }
+  
+  // Now do error handling but only if not in handshake mode.
+  if ((!client->startup) && (*errCode != RRC_RCV_PDU_NO_ERROR))
         {
-          if (ret == 1)
+    char errStr[RRC_MAX_STRING];
+    memset(errStr, '0', RRC_MAX_STRING);
+
+    if (*errCode == RRC_RCV_PDU_MEMORY_ERROR)
           {
-            // BZ599 - Changed typecase from (int) to (uintptr_t) to prevent
-            // compiler warnings and other nasty side affects while compiling
-            // on 32 and 64 bit OS.
-            close((uintptr_t)getClientFDPtr(&client->clSock));
+      *errCode = RPKI_EC_INTERNAL_ERROR;
+      LOG(LEVEL_ERROR, "Not enough memory!");      
           }
-          return;
+    
+    switch (*errCode)
+    {
+      case RPKI_EC_CORRUPT_DATA:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_CORRUPT_DATA);
+        break;
+      case RPKI_EC_NO_DATA_AVAILABLE:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_INTERNAL_ERROR);
+        break;
+      case RPKI_EC_INVALID_REQUEST:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_INVALID_REQUEST);
+        break;
+      case RPKI_EC_UNSUPPORTED_PROT_VER:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_UNSUPPORTED_PROT_VER);
+        break;
+      case RPKI_EC_UNSUPPORTED_PDU:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_UNSUPPORTED_PDU);
+        break;
+      case RPKI_EC_UNKNOWN_WITHDRAWL:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_UNKNOWN_WITHDRAWL);
+        break;
+      case RPKI_EC_DUPLICATE_ANNOUNCEMENT:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_DUPLICATE_ANNOUNCEMENT);
+        break;
+      case RPKI_EC_UNEXPECTED_PROTOCOL_VERSION:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_UNEXPECTED_PROTOCOL_VERSION);
+        break;
+      case RPKI_EC_RESERVED:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_RESERVED);
+        break;        
+      case RPKI_EC_INTERNAL_ERROR:
+      default:
+        *errCode = RPKI_EC_INTERNAL_ERROR;
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_INTERNAL_ERROR);
+        break;
         }
+        
+    switch (*errCode)
+    {
+      case RPKI_EC_CORRUPT_DATA:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_CORRUPT_DATA);
         break;
-      case PDU_TYPE_RESERVED :
-        LOG(LEVEL_ERROR, "Received reserved RPKI-PDU Type 255");
+      case RPKI_EC_NO_DATA_AVAILABLE:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_INTERNAL_ERROR);
         break;
+      case RPKI_EC_INVALID_REQUEST:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_INVALID_REQUEST);
+        break;
+      case RPKI_EC_UNSUPPORTED_PROT_VER:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_UNSUPPORTED_PROT_VER);
+        break;
+      case RPKI_EC_UNSUPPORTED_PDU:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_UNSUPPORTED_PDU);
+        break;
+      case RPKI_EC_UNKNOWN_WITHDRAWL:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_UNKNOWN_WITHDRAWL);
+        break;
+      case RPKI_EC_DUPLICATE_ANNOUNCEMENT:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_DUPLICATE_ANNOUNCEMENT);
+        break;
+      case RPKI_EC_UNEXPECTED_PROTOCOL_VERSION:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_UNEXPECTED_PROTOCOL_VERSION);
+        break;
+      case RPKI_EC_RESERVED:
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_RESERVED);
+        break;        
+      case RPKI_EC_INTERNAL_ERROR:
       default :
-        // We handled all known types already
-        LOG(LEVEL_ERROR, "Unknown/unexpected RPKI-PDU Type %u", hdr->type);
+        *errCode = RPKI_EC_INTERNAL_ERROR;
+        snprintf (errStr, RRC_MAX_STRING, "%s", RPKI_ESTR_INTERNAL_ERROR);
+        break;
     }
+    
+    sendErrorReport(client, *errCode, (uint8_t*)hdr, pduLen, 
+                    errStr, strlen(errStr));
   }
+  
   // Release the buffer again.
   free(byteBuffer);
+  
+  return *errCode == RRC_RCV_PDU_NO_ERROR;
 }
 
 
@@ -483,6 +779,9 @@ static void* manageConnection (void* cli
 {
   RPKIRouterClient* client = (RPKIRouterClient*)clientPtr;
   int               sec;
+  int               errCode;
+  // Counter for errors 
+  int errCount = 0;
 
   struct sigaction act;
   sigset_t errmask;
@@ -507,19 +806,52 @@ static void* manageConnection (void* cli
       // is either lost, closed, or the end of data is received (single request)
       // Modified call with 0.5.0.0 to use variable as second parameter rather
       // than false
-      receivePDUs(client, client->stopAfterEndOfData);
+      receivePDUs(client, client->stopAfterEndOfData, &errCode, true);      
+      // Check the expected response, 
+      switch (client->lastRecv)
+      {
+        case PDU_TYPE_CACHE_RESPONSE:
+          // Now, keep on going and receive data.
+          receivePDUs(client, client->stopAfterEndOfData, &errCode, false);
+
       if (client->stopAfterEndOfData)
       {
         client->stop = true;
       }
+          break;
+        case PDU_TYPE_ERROR_REPORT:
+          // Most likely an error regarding the version number, keep on going if 
+          // we can downgrade the version (and only if)
+          LOG(LEVEL_DEBUG, "Version conflict registered. ");
+          switch (errCode)
+          {
+            case RPKI_EC_UNSUPPORTED_PROT_VER:
+            case RPKI_EC_UNEXPECTED_PROTOCOL_VERSION:
+              // Stop if client was not allowed to downgrade.
+              client->stop = !client->params->allowDowngrade;
+              break;
+            default:
+              LOG(LEVEL_DEBUG, "PDU receive error[%u]!", errCode);
+              errCount++;
+              if (errCount >= RRC_MAX_ERRCT)
+              {
+                LOG(LEVEL_ERROR, "Experienced %u errors during receiving PDU's"
+                                 ", Stop client!", errCount);
+                client->stop = true;
+              }
+          }
+          break;
+        default:
+          RAISE_ERROR("Unexpected protocol behavior!");
+          client->stop = true;
+      }
     }
-
-    // The connection is lost or did not even exist yet.
 
     // Test if the connection stopped!
     if (client->stop)
     {
       LOG(LEVEL_DEBUG, HDR "Client Connection was stopped!", pthread_self());
+      close((uintptr_t)getClientFDPtr(&client->clSock));
       break;
     }
 
@@ -531,6 +863,8 @@ static void* manageConnection (void* cli
 
     if (sec == -1)
     { // Stop trying to re-establish the connection
+      client->stop = true;
+      close((uintptr_t)getClientFDPtr(&client->clSock));
       pthread_exit((void*)1);
     }
 
@@ -540,7 +874,8 @@ static void* manageConnection (void* cli
       client->startup = true;
     }
 
-    // Now try to reconnect.
+    // Now try to reconnect if not stopped.
+    client->clSock.reconnect = !client->stop;
     reconnectToServer(&client->clSock, sec, MAX_RECONNECTION_ATTEMPTS);
 
     // See if the session_id changed!
@@ -568,7 +903,7 @@ static void* manageConnection (void* cli
         // Receive and process all PDUs. The flag client->session_id_changed
         // is already set to false.
         LOG (LEVEL_DEBUG, "SESSION ID CHANGE: RECEIVE DATA", pthread_self());
-        receivePDUs(client, true);
+        receivePDUs(client, true, &errCode, false);
       }
       LOG (LEVEL_DEBUG, "SESSION ID CHANGE: DATA ESTABLISHED", pthread_self());
       if (client->params->sessionIDEstablishedCallback != NULL)
@@ -698,6 +1033,41 @@ void releaseRPKIRouterClient (RPKIRouter
 }
 
 /**
+ * Wrapper for function sendNum. This wrapper does call the debugCallback in 
+ * case it is specified. The call will only be done if the call to sendNum was
+ * successful.
+ *  
+ * @param client The RPKI Router Client (this)
+ * @param hdr The header to be send.
+ * 
+ * @return true if the packed was send, otherwise false.
+ * 
+ * @since 0.5.0.3 
+ */
+static bool _sendPDU(RPKIRouterClient* client, RPKICommonHeader* hdr)
+{
+  bool succ = sendNum(getClientFDPtr(&client->clSock), hdr, ntohl(hdr->length)); 
+  if (succ)
+  {
+    client->lastSent = hdr->type;
+  }
+  if (client->params->debugSendCallback != NULL)
+  {
+    printf("Sending packet:");
+    if (succ)
+    {
+      printf("\n");
+      client->params->debugSendCallback(client, hdr);
+    }
+    else
+    {
+      printf (" failed!\n");
+    }
+  }
+  return succ;
+}
+
+/**
  * Send a RESET QUERY to the validation cache to re-request the complete
  * data
  *
@@ -720,16 +1090,9 @@ bool sendResetQuery (RPKIRouterClient* s
     hdr.length   = htonl(sizeof(RPKIResetQueryHeader));
 
     lockMutex(&self->writeMutex);
-    self->lastSent = PDU_TYPE_RESET_QUERY;
 
-    succ = sendNum (getClientFDPtr(&self->clSock), &hdr,
-                    sizeof(RPKIResetQueryHeader));
-
-    if (succ)
-    {
-      self->lastSent = PDU_TYPE_RESET_QUERY;
-    }
-    else
+    succ = _sendPDU (self, (RPKICommonHeader*)&hdr);
+    if (!succ)
     {
       // TODO: Maybe just close the old socket and set both to -1
       // The socket was not closed but the FD was set to -1. reset it to allow
@@ -747,6 +1110,66 @@ bool sendResetQuery (RPKIRouterClient* s
 }
 
 /**
+ * Send an error report to the server.
+ * 
+ * @param self the instance of rpki router client.
+ * @param errCode The error code to be used.
+ * @param erronPDU The PDU containing the error.
+ * @param lenErronPDU Length of the erroneous PDU (host format).
+ * @param errText The administrative text message that accompanies the error.
+ * @param lenErrText Th length of the text string (host format).
+ * 
+ * @return true if the packet could be send successfully.
+ * 
+ * @since 0.5.0.3
+ */
+bool sendErrorReport(RPKIRouterClient* self, u_int16_t errCode,
+                     u_int8_t* erronPDU, u_int32_t lenErronPDU,
+                     char* errText, u_int32_t lenErrText)
+{
+  u_int32_t totalLen = sizeof(RPKIErrorReportHeader) + lenErronPDU
+                       + (4 + lenErrText);  // 4 byte for length field + text
+  bool  succ = false;
+
+  if (self->clSock.clientFD != -1)
+  {
+    u_int8_t* buff = malloc(totalLen);
+    memset(buff, 0, totalLen);
+    u_int32_t* hdr_len_err_txt = NULL;
+    RPKIErrorReportHeader* hdr = (RPKIErrorReportHeader*)buff;
+    hdr->version      = self->version;
+    hdr->type         = PDU_TYPE_ERROR_REPORT;
+    hdr->error_number = htons(errCode);
+    hdr->length       = htonl(totalLen);
+    hdr->len_enc_pdu  = htonl(lenErronPDU);
+    // Move buffer to position of error PDU
+    buff += sizeof(RPKIErrorReportHeader);
+    memcpy(buff, erronPDU, lenErronPDU);
+    buff += lenErronPDU;
+    hdr_len_err_txt  = (u_int32_t*)buff;
+    *hdr_len_err_txt = htonl(lenErrText);
+    buff += sizeof(u_int32_t);
+    memcpy(buff, errText, lenErrText); 
+    // Set buffer back to start of header; 
+    buff = (u_int8_t*)hdr;
+
+    lockMutex(&self->writeMutex);
+    LOG(LEVEL_DEBUG, HDR "Sending Serial Query...\n", pthread_self());
+
+    succ  = _sendPDU(self, (RPKICommonHeader*)hdr); 
+    unlockMutex(&self->writeMutex);
+
+    memset(buff, 0, totalLen);
+    free(buff);
+
+    buff = NULL;
+    hdr  = NULL;
+  }
+   
+  return succ;
+}
+
+/**
  * Send a SERIAL QUERY to the rpki validation cache. The sessionID and serial
  * number are extracted of the router client itself.
  *
@@ -757,37 +1180,24 @@ bool sendResetQuery (RPKIRouterClient* s
 bool sendSerialQuery (RPKIRouterClient* self)
 {
   RPKISerialQueryHeader hdr;
+  bool  succ = false;
+
+  if (self->clSock.clientFD != -1)
+  {
   hdr.version   = self->version;
   hdr.type      = PDU_TYPE_SERIAL_QUERY;
   hdr.sessionID = self->sessionID;
   hdr.length    = htonl(sizeof(RPKISerialQueryHeader));
   hdr.serial    = self->serial;
 
-  bool succ  = false;
-
   lockMutex(&self->writeMutex);
   LOG(LEVEL_DEBUG, HDR "Sending Serial Query...\n", pthread_self());
 
-  if (sendNum(getClientFDPtr(&self->clSock), &hdr,
-              sizeof(RPKISerialQueryHeader)))
-  {
-    self->lastSent = PDU_TYPE_SERIAL_QUERY;
-  }
+    succ  = _sendPDU(self, (RPKICommonHeader*)&hdr);
   unlockMutex(&self->writeMutex);
-
-  return succ;
 }
 
-//TODO: Documentation missing
-inline RPKIRouterPDUType getLastSentPDUType(RPKIRouterClient* self)
-{
-  return self->lastSent;
-}
-
-//TODO: Documentation missing
-inline RPKIRouterPDUType getLastReceivedPDUType(RPKIRouterClient* self)
-{
-  return self->lastRecv;
+  return succ;
 }
 
 //TODO: Documentation missing
@@ -810,4 +1220,3 @@ void generalSignalProcess(void)
   sigaction(SIGPIPE, &act, NULL);
   pthread_sigmask(SIG_UNBLOCK, &errmask, NULL);
 }
-
--- ./src/server/rpki_handler.c	2017-12-05 16:45:32.000000000 -0500
+++ /opt/project/NIST-gitlab/srx-server/./src/server/rpki_handler.c	2020-05-18 02:16:10.089963106 -0400
@@ -26,9 +26,14 @@
  *
  * Changelog:
  * -----------------------------------------------------------------------------
- *  0.5.1.0 - 2017/10/13 - oborchert
+ * 0.5.1.0  - 2018/03/09 - oborchert 
+ *            * BZ1263: Merged branch 0.5.0.x (version 0.5.0.4) into trunk 
+ *              of 0.5.1.0.
+ *          - 2017/10/13 - oborchert
  *            * BZ1238: Used valCacheID Id as key source during key 
  *              registration.
+ *  0.5.0.3 - 2018/02/26 - oborchert
+ *            * fixed incorrect import.
  *  0.5.0.0 - 2017/07/08 - oborchert
  *            * Added final steps to fully integrate BGPsec path validation. 
  *          - 2017/07/06 - oborchert
@@ -63,8 +68,8 @@
 #include "server/rpki_handler.h"
 #include "server/ski_cache.h"
 #include "server/update_cache.h"
+#include "server/bgpsec_handler.h"
 #include "util/log.h"
-#include "bgpsec_handler.h"
 
 ///////////////////
 // Constants
--- ./src/util/mutex.h	2017-05-19 21:10:06.000000000 -0400
+++ /opt/project/NIST-gitlab/srx-server/./src/util/mutex.h	2020-05-18 02:16:10.102963087 -0400
@@ -24,10 +24,13 @@
  * @note Currently based on PThread
  * log.h is used for error reporting.
  * 
- * @version 0.3.0.10
+ * @version 0.5.0.6
  *
  * Changelog:
  * -----------------------------------------------------------------------------
+ * 0.5.0.6 - 2018/11/20 - oborchert
+ *           * Removed "inline" keyword from functions - caused linker error 
+ *             on Ubuntu 18
  * 0.3.0.10 - 2015/11/09 - oborchert
  *            * Removed types.h
  *            * Added Changelog
@@ -105,6 +108,6 @@ extern int waitCond(Cond *cond, Mutex *s
 extern int sem_wait_wrapper(sem_t *sem_var, uint32_t millis);
 
 
-inline int destroyCond(Cond *cond);
+int destroyCond(Cond *cond);
 #endif // !__MUTEX_H__
 
--- ./src/shared/rpki_router.h	2017-07-11 13:40:19.000000000 -0400
+++ /opt/project/NIST-gitlab/srx-server/./src/shared/rpki_router.h	2020-05-18 02:16:10.095963097 -0400
@@ -22,10 +22,19 @@
  *
  * RPKI/Router definitions.
  *
- * @version 0.5.0.0
+ * @version 0.5.0.4
  *
  * Changelog:
  * -----------------------------------------------------------------------------
+ * 0.5.0.4  - 2018/03/07 - oborchert
+ *            * Added new error code of RFC 8210
+ *            * Added error string defines.
+ * 0.5.0.3  - 2018/02/28 - oborchert
+ *            * Modified RPKI_CONNECTION_TIMEOUT from 3 seconds to 10 seconds.
+ *          - 2018/02/22 - oborchert
+ *            * Updated the define RPKI_RTR_PROTOCOL_VERSION from 0 to 1
+ *            * Added define RPKI_DEFAULT_CACHE_PORT 323
+ *            * Added define RPKI_DEFAULT_CACHE "localhost"
  * 0.5.0.0  - 2017/07/09 - oborchert
  *            * Added include <srx/srxcryptoapi.h> and replaced hard coded 
  *              values with the appropriate defines
@@ -58,6 +67,29 @@
 #include <srx/srxcryptoapi.h>
 #include "util/prefix.h"
 
+/** The lowest bit is set if the prefix PDU is an announcement */
+#define PREFIX_FLAG_ANNOUNCEMENT  0x01
+
+/** The current protocol implementation. */
+#define RPKI_RTR_PROTOCOL_VERSION 1
+/** The default RPKI server port */
+#define RPKI_DEFAULT_CACHE_PORT 323
+/** The default address for a RPKI validation cache */
+#define RPKI_DEFAULT_CACHE "localhost"
+/** The default connection attempt timeout after 10 seconds. */
+#define RPKI_CONNECTION_TIMEOUT 10
+
+#ifndef SRX_SERVER_PACKAGE
+// Is provided by Makefile as CFLAGS -I
+#define SRX_SERVER_PACKAGE  "NA"
+#endif
+// Some Macros to deal with the SRX_REVISION compiler parameter
+#define SRX_TOOLS_STRINGIFY_ARG(ARG) " " #ARG
+#define SRX_TOOLS_STRINGIFY_IND(ARG) SRX_TOOLS_STRINGIFY_ARG(ARG)
+
+// Used version number -  make a string of the define
+#define SRX_TOOLS_VERSION  SRX_TOOLS_STRINGIFY_IND(SRX_SERVER_PACKAGE)
+
 /**
  * PDU Types
  */
@@ -72,7 +104,7 @@ typedef enum {
   PDU_TYPE_CACHE_RESET    = 8,  // 5.9
   PDU_TYPE_ROUTER_KEY     = 9,  // 5.10
   PDU_TYPE_ERROR_REPORT   = 10, // 5.11
-  PDU_TYPE_RESERVED       = 255
+  PDU_TYPE_RESERVED       = 255 // 14
 } RPKIRouterPDUType;
 
 /**
@@ -87,14 +119,21 @@ typedef enum {
     RPKI_EC_UNSUPPORTED_PDU        = 5,
     RPKI_EC_UNKNOWN_WITHDRAWL      = 6,
     RPKI_EC_DUPLICATE_ANNOUNCEMENT = 7,
-    RPKI_EC_RESERVED               = 255
+    RPKI_EC_UNEXPECTED_PROTOCOL_VERSION = 8,   // NEW IN RFC8210
+    RPKI_EC_RESERVED                    = 255  //
 } RPKIErrorCode;
 
-/** The lowest bit is set if the prefix PDU is an announcement */
-#define PREFIX_FLAG_ANNOUNCEMENT  0x01
-
-/** The current protocol implementation. */
-#define RPKI_RTR_PROTOCOL_VERSION 0;
+// Added error text with version 0.5.0.4
+#define RPKI_ESTR_CORRUPT_DATA                "Corrupt Data\0"
+#define RPKI_ESTR_INTERNAL_ERROR              "Internal Error\0"
+#define RPKI_ESTR_NO_DATA_AVAILABLE           "No Data Available\0"
+#define RPKI_ESTR_INVALID_REQUEST             "invalid Request\0"
+#define RPKI_ESTR_UNSUPPORTED_PROT_VER        "Unsupported Protocol Version\0"
+#define RPKI_ESTR_UNSUPPORTED_PDU             "Unsupported PDU\0"
+#define RPKI_ESTR_UNKNOWN_WITHDRAWL           "Unknown Withdrawal\0"
+#define RPKI_ESTR_DUPLICATE_ANNOUNCEMENT      "Duplicate Announcement\0"
+#define RPKI_ESTR_UNEXPECTED_PROTOCOL_VERSION "Unexpected Protocol Version\0"
+#define RPKI_ESTR_RESERVED                    "Reserved\0"
 
 //
 // The following types could be optimized but
